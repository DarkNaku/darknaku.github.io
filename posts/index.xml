<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 코딩하는 나긔</title>
    <link>http://darknaku.github.io/posts/</link>
    <description>Recent content in Posts on 코딩하는 나긔</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <lastBuildDate>Tue, 10 May 2022 15:38:31 +0900</lastBuildDate><atom:link href="http://darknaku.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Morton Code Encode / Decode</title>
      <link>http://darknaku.github.io/posts/20220510_0/</link>
      <pubDate>Tue, 10 May 2022 15:38:31 +0900</pubDate>
      
      <guid>http://darknaku.github.io/posts/20220510_0/</guid>
      <description>2차원 또는 3차원 좌표를 Z-curve 순서의 ulong형 값으로 변환하거나 복원하는 함수입니다.
자세한 내용은 링크를 참고하세요.
아래 코드 좌표공간 최대값은 65535 입니다.
3차원 좌표와 2진수 값 그리고 변환한 인덱스값
node | bits | index -----:|:----:|:----- 0,0,0 | 000 | 0 0,0,1 | 001 | 1 0,1,0 | 010 | 2 0,1,1 | 011 | 3 1,0,0 | 100 | 4 1,0,1 | 101 | 5 1,1,0 | 110 | 6 1,1,1 | 111 | 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  public static ulong MortonEncode2D(ulong x, ulong y) {  x = (x | x &amp;lt;&amp;lt; 32) &amp;amp; 0x1f00000000ffff;  x = (x | x &amp;lt;&amp;lt; 16) &amp;amp; 0x1f0000ff0000ff;  x = (x | x &amp;lt;&amp;lt; 8) &amp;amp; 0x100f00f00f00f00f;  x = (x | x &amp;lt;&amp;lt; 4) &amp;amp; 0x10c30c30c30c30c3;  x = (x | x &amp;lt;&amp;lt; 2) &amp;amp; 0x1249249249249249;   y = (y | y &amp;lt;&amp;lt; 32) &amp;amp; 0x1f00000000ffff;  y = (y | y &amp;lt;&amp;lt; 16) &amp;amp; 0x1f0000ff0000ff;  y = (y | y &amp;lt;&amp;lt; 8) &amp;amp; 0x100f00f00f00f00f;  y = (y | y &amp;lt;&amp;lt; 4) &amp;amp; 0x10c30c30c30c30c3;  y = (y | y &amp;lt;&amp;lt; 2) &amp;amp; 0x1249249249249249;   return x | (y &amp;lt;&amp;lt; 1); }  public static void MortonDecode2D(ulong v, out ulong x, out ulong y) {  x = v &amp;amp; 0x1249249249249249;  x = (x ^ x &amp;gt;&amp;gt; 2) &amp;amp; 0x10c30c30c30c30c3;  x = (x ^ x &amp;gt;&amp;gt; 4) &amp;amp; 0x100f00f00f00f00f;  x = (x ^ x &amp;gt;&amp;gt; 8) &amp;amp; 0x1f0000ff0000ff;  x = (x ^ x &amp;gt;&amp;gt; 16) &amp;amp; 0x1f00000000ffff;   y = (v &amp;gt;&amp;gt; 1) &amp;amp; 0x1249249249249249;  y = (y ^ y &amp;gt;&amp;gt; 2) &amp;amp; 0x10c30c30c30c30c3;  y = (y ^ y &amp;gt;&amp;gt; 4) &amp;amp; 0x100f00f00f00f00f;  y = (y ^ y &amp;gt;&amp;gt; 8) &amp;amp; 0x1f0000ff0000ff;  y = (y ^ y &amp;gt;&amp;gt; 16) &amp;amp; 0x1f00000000ffff; }  public static ulong MortonEncode3D(ulong x, ulong y, ulong z) {  x = (x | x &amp;lt;&amp;lt; 32) &amp;amp; 0x1f00000000ffff;  x = (x | x &amp;lt;&amp;lt; 16) &amp;amp; 0x1f0000ff0000ff;  x = (x | x &amp;lt;&amp;lt; 8) &amp;amp; 0x100f00f00f00f00f;  x = (x | x &amp;lt;&amp;lt; 4) &amp;amp; 0x10c30c30c30c30c3;  x = (x | x &amp;lt;&amp;lt; 2) &amp;amp; 0x1249249249249249;   y = (y | y &amp;lt;&amp;lt; 32) &amp;amp; 0x1f00000000ffff;  y = (y | y &amp;lt;&amp;lt; 16) &amp;amp; 0x1f0000ff0000ff;  y = (y | y &amp;lt;&amp;lt; 8) &amp;amp; 0x100f00f00f00f00f;  y = (y | y &amp;lt;&amp;lt; 4) &amp;amp; 0x10c30c30c30c30c3;  y = (y | y &amp;lt;&amp;lt; 2) &amp;amp; 0x1249249249249249;   z = (z | z &amp;lt;&amp;lt; 32) &amp;amp; 0x1f00000000ffff;  z = (z | z &amp;lt;&amp;lt; 16) &amp;amp; 0x1f0000ff0000ff;  z = (z | z &amp;lt;&amp;lt; 8) &amp;amp; 0x100f00f00f00f00f;  z = (z | z &amp;lt;&amp;lt; 4) &amp;amp; 0x10c30c30c30c30c3;  z = (z | z &amp;lt;&amp;lt; 2) &amp;amp; 0x1249249249249249;   return x | (y &amp;lt;&amp;lt; 1) | (z &amp;lt;&amp;lt; 2); }  public static void MortonDecode3D(ulong v, out ulong x, out ulong y, out ulong z) {  x = v &amp;amp; 0x1249249249249249;  x = (x ^ x &amp;gt;&amp;gt; 2) &amp;amp; 0x10c30c30c30c30c3;  x = (x ^ x &amp;gt;&amp;gt; 4) &amp;amp; 0x100f00f00f00f00f;  x = (x ^ x &amp;gt;&amp;gt; 8) &amp;amp; 0x1f0000ff0000ff;  x = (x ^ x &amp;gt;&amp;gt; 16) &amp;amp; 0x1f00000000ffff;   y = (v &amp;gt;&amp;gt; 1) &amp;amp; 0x1249249249249249;  y = (y ^ y &amp;gt;&amp;gt; 2) &amp;amp; 0x10c30c30c30c30c3;  y = (y ^ y &amp;gt;&amp;gt; 4) &amp;amp; 0x100f00f00f00f00f;  y = (y ^ y &amp;gt;&amp;gt; 8) &amp;amp; 0x1f0000ff0000ff;  y = (y ^ y &amp;gt;&amp;gt; 16) &amp;amp; 0x1f00000000ffff;   z = (v &amp;gt;&amp;gt; 2) &amp;amp; 0x1249249249249249;  z = (z ^ z &amp;gt;&amp;gt; 2) &amp;amp; 0x10c30c30c30c30c3;  z = (z ^ z &amp;gt;&amp;gt; 4) &amp;amp; 0x100f00f00f00f00f;  z = (z ^ z &amp;gt;&amp;gt; 8) &amp;amp; 0x1f0000ff0000ff;  z = (z ^ z &amp;gt;&amp;gt; 16) &amp;amp; 0x1f00000000ffff; }   </description>
    </item>
    
    <item>
      <title>두 백터가 이루는 각을 360도로 구하기</title>
      <link>http://darknaku.github.io/posts/20220502_0/</link>
      <pubDate>Mon, 02 May 2022 02:52:00 +0900</pubDate>
      
      <guid>http://darknaku.github.io/posts/20220502_0/</guid>
      <description>두 백터가 이루고 있는 각도를 0 ~ 360으로 얻는 코드.
1 2 3 4 5 6 7  public float GetAngle (Vector3 a, Vector3 b) {  var dot = (a.x * b.x) + (a.y * b.y);  var determinant = (a.x * b.y) - (a.y * b.x);  var degree = Mathf.Atan2(determinant, dot) * Mathf.Rad2Deg;   return (degree &amp;lt; 0f) ? 180f + (180f + degree) : degree; }   </description>
    </item>
    
    <item>
      <title>3점을 지나는 원</title>
      <link>http://darknaku.github.io/posts/20220106_3/</link>
      <pubDate>Thu, 06 Jan 2022 14:14:30 +0900</pubDate>
      
      <guid>http://darknaku.github.io/posts/20220106_3/</guid>
      <description>이전 포스팅 클래스에 추가
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class Circle { 	. 	. 	. 	public static Circle CreateCircle(Vector2 p1, Vector2 p2, Vector2 p3) { 	float a = p1.x * (p2.y - p3.y) - p1.y * (p2.x - p3.x) + p2.x * p3.y - p3.x * p2.</description>
    </item>
    
    <item>
      <title>반지름을 알고 두 원에 접하는 원의 중심</title>
      <link>http://darknaku.github.io/posts/20220106_2/</link>
      <pubDate>Thu, 06 Jan 2022 14:02:26 +0900</pubDate>
      
      <guid>http://darknaku.github.io/posts/20220106_2/</guid>
      <description>두 원에 접하는 원의 중심은 대칭으로 두 곳이 존재한다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public class Circle { 	public Vector2 Center { get; private set; } 	public float Radius { get; private set; }  	public Circle(Vector2 center, float radius) { 	Center = center; 	Radius = radius; 	}  	public bool GetIntersectionPoints(Circle other, out Vector2 p1, out Vector2 p2) { 	p1 = default(Vector2); 	p2 = default(Vector2);  	float distance = Vector2.</description>
    </item>
    
    <item>
      <title>좌표가 삼각형 안쪽에 있는지 판별</title>
      <link>http://darknaku.github.io/posts/20220106_1/</link>
      <pubDate>Thu, 06 Jan 2022 13:49:43 +0900</pubDate>
      
      <guid>http://darknaku.github.io/posts/20220106_1/</guid>
      <description>좌표가 삼각형 안쪽에 있는 경우 참, 아닌 겨우 거짓을 반환
1 2 3 4 5 6 7  private bool IsInsideOnTriangle(Vector2 p, Vector2 t1, Vector2 t2, Vector2 t3) {  float l1 = (p.x - t1.x) * (t3.y - t1.y) - (t3.x - t1.x) * (p.y - t1.y);  float l2 = (p.x - t2.x) * (t1.y - t2.y) - (t1.x - t2.x) * (p.y - t2.y);  float l3 = (p.</description>
    </item>
    
    <item>
      <title>좌표가 원 또는 구 영역 안에 있는지 판별</title>
      <link>http://darknaku.github.io/posts/20220106_0/</link>
      <pubDate>Thu, 06 Jan 2022 08:28:10 +0900</pubDate>
      
      <guid>http://darknaku.github.io/posts/20220106_0/</guid>
      <description>좌표가 원이나 구 안쪽에 있는 경우 -1, 원이나 구 경계선에 있는 경우 0, 원이나 구 밖에 있는 경우는 1 을 반환한다.
원 안의 좌표 판별
1 2 3 4 5 6 7 8 9 10 11 12  public static int IsInCircle(float pointX, float pointY, float centerX, float centerY, float radius) { 	var a = Mathf.Pow(pointX - centerX, 2) + Mathf.Pow(pointY - centerY, 2); 	var b = Mathf.Pow(radius, 2); 		if (a &amp;lt; b) { 	return -1; 	} else if (a == b) { 	return 0; 	} else { 	return 1; 	} }   구 안의 좌표 판별</description>
    </item>
    
  </channel>
</rss>
